
ðŸŸ¢ Step 1: What is Node.js?

âœ… Simple Definition:
Node.js is a JavaScript runtime environment that allows you to run JavaScript code outside the browser â€” mainly used for building backend (server-side) applications.

âœ… Why Node.js was created:
Originally, JavaScript was only used in browsers. Developers wanted to use it on the server too â€” and that's why Node.js was created in 2009 by Ryan Dahl.
It uses the V8 JavaScript engine (the same used in Google Chrome) to execute JavaScript code on the server.

âœ… Key Features:
1. Non-blocking I/O â€“ handles multiple requests at the same time (asynchronous).
2. Event-driven architecture â€“ reacts to events like â€œrequest receivedâ€, â€œfile read completeâ€, etc.
3. Single-threaded â€“ but very efficient due to the event loop.
4. Fast performance â€“ because it uses the V8 engine.
5. Cross-platform â€“ works on Windows, macOS, and Linux.

âœ… What Can You Build with Node.js?
- Web applications (like APIs)
- Real-time chat apps (like WhatsApp clone)
- RESTful APIs
- Command-line tools
- Microservices
- Streaming services

âœ… Companies using Node.js:
- Netflix
- LinkedIn
- Uber
- PayPal
- Walmart

âœ… Why you Should Learn Node.js:
- Same language for frontend and backend (JavaScript)
- Huge job demand
- Easy to get started
- Fast-growing ecosystem with npm (Node Package Manager)

ðŸŸ¢ Step 2: How Node.js Works (Behind the Scenes)

âœ… The Core Components of Node.js:

1. V8 Engine
   - JavaScript engine built by Google.
   - Compiles JS code to machine code.

2. Libuv
   - C++ library to handle asynchronous operations.
   - Provides:
     - Event loop
     - Thread pool

3. Node.js APIs
   - Built-in modules like fs, http, path, etc.
   - Allow access to system-level features.

âœ… The Flow of a Node.js Program:

1. JavaScript code is written.
2. V8 engine compiles and runs it.
3. For I/O tasks, Libuv sends tasks to thread pool.
4. Main thread continues running (non-blocking).
5. When I/O finishes, callback goes to the event loop.
6. Event loop runs the callback at the right time.

âœ… The Event Loop â€“ The Brain of Node.js:
The event loop is like a restaurant waiter:
- Takes orders (requests)
- Passes them to kitchen (thread pool)
- Keeps taking new orders while cooking happens
- Serves food (calls callback) when ready

âœ… Visual Summary:

Your Code
   â†“
[V8 Engine] â€“ runs JS
   â†“
[Libuv] â€“ handles I/O (e.g., fs, http)
   â†“
Thread Pool â€“ offloads long tasks
   â†“
Event Loop â€“ waits for task to finish
   â†“
Callback â€“ runs when task is ready

âœ… Event-driven Architecture:
- Node.js works on events and listeners.
- Instead of following step-by-step instructions, Node.js waits and reacts to events.
- For example:
    - When a user sends a request âž an event is triggered.
    - When a file is read âž another event is triggered.
- Each event has a callback function that runs when the event occurs.
- This makes Node.js great for apps that need to handle many users at once (like chat apps or real-time updates).
âœ… EventEmitter Example:

const EventEmitter = require('events');

// create a new instance of EventEmitter
const myEmitter = new EventEmitter();

// attach a listener for the 'greet' event
myEmitter.on('greet', () => {
  console.log('Hello, world!');
});

// emit the 'greet' event
myEmitter.emit('greet');

In this code, we first require the events module and create a new instance of the EventEmitter class called myEmitter. We then attach a listener for the 'greet' event using the on() method. Finally, we emit the 'greet' event using the emit() method, which will trigger the listener that we attached.

This is just a simple example, but in a real-world application, you can use the EventEmitter class to handle a wide range of events, such as incoming requests from clients, file I/O operations, database queries, and more. By using an event-driven approach, you can build highly scalable and efficient network applications with Node.js.


âœ… Non-blocking I/O (Asynchronous I/O) 

In traditional programming (like in languages such as PHP or Java), when the server performs an I/O operation (like reading a file or querying a database), it waits until that task is done before moving on to the next one. This is called blocking â€” it blocks the entire thread during that operation.

ðŸš« Blocking I/O Example (Not Node.js style):
const data = fs.readFileSync('file.txt'); // Waits until the file is fully read
console.log('File content:', data);       // Only runs after file reading is done

This blocks other code from running until the file is read.

âœ… Non-blocking I/O (Node.js style):

In Node.js, non-blocking I/O means it does not wait for the task to finish. Instead, it starts the task and immediately moves to the next line of code. When the task finishes, it runs a callback function or promise to handle the result.

fs.readFile('file.txt', (err, data) => {
  console.log('File content:', data); // Runs later, when file is read
});
console.log('Reading file...'); // Runs immediately, without waiting

ðŸ§  Why it's powerful:
- Handle thousands of requests without creating new threads
- Stay fast and lightweight
- Use the event loop to run callbacks when I/O operations finish

This is especially useful in web servers where many users make requests at the same time. Node.js handles them efficiently without blocking others.






Node.js - Part 2

ðŸŸ¢ Step 3: HTTP Server Creation in Node.js

âœ… What is an HTTP server?
An HTTP server handles requests from clients (like web browsers) and sends back responses.

âœ… Why this server?

Teaches how the backend communicates with the frontend.
Builds a foundation to develop web applications and APIs.

âœ… Basic HTTP Server Example:

const http = require('http');

const server = http.createServer((req, res) => {
  res.end('Hello from Node.js server!');
});

server.listen(3000, () => {
  console.log('Server is running at http://localhost:3000/');
});

ðŸŸ¢ Step 4: Node.js Modules and Their Types

âœ… What are modules?
Modules are reusable blocks of code.

âœ… Types of Modules:

1. Core Modules - built into Node.js (e.g., `fs`, `http`)
2. Local Modules - your own custom files
3. Third-party Modules - installed via npm (e.g., `express`)

âœ… Examples:

Core Module Example:

const os = require('os');
console.log('OS Platform:', os.platform());

Local Module Example:

`math.js`:

function add(a, b) {
  return a + b;
}
module.exports = add;

`app.js`:

const add = require('./math');
console.log(add(5, 3)); // Output: 8

* Third-party Module Example:

npm install moment

const moment = require('moment');
console.log(moment().format('MMMM Do YYYY, h:mm:ss a'));



1. Get Current Date and Time

js
moment().format();


ðŸ§¾ Output: `"2025-05-22T14:30:00+05:30"`


2. Format a Date

js
moment().format('MMMM Do YYYY, h:mm:ss a');


ðŸ§¾ Output: `"May 22nd 2025, 2:30:00 pm"`


3. Parse a Date String

js
moment("2025-12-25", "YYYY-MM-DD").format("MMM Do");


ðŸ§¾ Output: `"Dec 25th"`


4. Add Time

js
moment().add(7, 'days').format('YYYY-MM-DD');


ðŸ§¾ Output: `"2025-05-29"`


5. Subtract Time

js
moment().subtract(2, 'months').format('YYYY-MM-DD');


ðŸ§¾ Output: `"2025-03-22"`


6. Date Difference (in Days)

js
moment("2025-05-22").diff(moment("2025-01-01"), 'days');


ðŸ§¾ Output: `141`


7. Check if One Date is Before Another

js
moment("2025-01-01").isBefore("2025-05-22");


ðŸ§¾ Output: `true`


8. Check if One Date is After Another

js
moment("2025-06-01").isAfter("2025-05-22");


ðŸ§¾ Output: `true`


9. Relative Time (Past)

js
moment("2025-01-01").fromNow();


ðŸ§¾ Output: `"5 months ago"`


10. Relative Time (Future)

js
moment().add(10, 'days').fromNow();


ðŸ§¾ Output: `"in 10 days"`


11. Start of a Time Unit

js
moment().startOf('month').format();


ðŸ§¾ Output: `"2025-05-01T00:00:00+05:30"`


12. End of a Time Unit

js
moment().endOf('year').format();


ðŸ§¾ Output: `"2025-12-31T23:59:59+05:30"`


13. Set Locale (e.g., French)

js
moment.locale('fr');


ðŸ§¾ Output: *(Changes moment output language to French)*


14. Format with Locale

js
moment().format('LLLL');


ðŸ§¾ Output: `"jeudi 22 mai 2025 14:30"`


ðŸŸ¢ Step 5: File Operations (CRUD)

âœ… Why file operations?
Teaches students to store, read, update, and delete data using the filesystem.

âœ… Examples using `fs` module:

* Create/Write File:

const fs = require('fs');
fs.writeFileSync('students.txt', 'Hello Students!');

* Read File:

const content = fs.readFileSync('students.txt', 'utf8');
console.log(content);

* Update File:

fs.appendFileSync('students.txt', '\\nWelcome to Node.js');

* Delete File:

fs.unlinkSync('students.txt');

ðŸŸ¢ Step 6: NodeMailer â€“ Sending Emails in Node.js

âœ… Why this NodeMailer?

* Real-world feature for sending emails (e.g., verifications, updates).
* Shows integration of Node.js with external services.

âœ… Setup:

1. Enable 2-Step Verification on your Gmail.
2. Create an App Password in Google account settings.
3. Use that app password in the code (not your Gmail password).

âœ… Install NodeMailer:

ash
npm install nodemailer

âœ… Complete Real-Time Example:

const nodemailer = require('nodemailer');
// Setup transporter
let transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: 'your_email@gmail.com',
    pass: 'your_app_password' // Use Gmail App Password
  }
});

// Email options
let mailOptions = {
  from: 'your_email@gmail.com',
  to: 'student@example.com',
  subject: 'Node.js Email Example',
  text: 'Hello! This is a test email from Node.js'
};

// Send email
transporter.sendMail(mailOptions, (error, info) => {
  if (error) {
    return console.log('Error:', error);
  }
  console.log('Email sent:', info.response);
});

âœ… Notes:

* NEVER hardcode real credentials.
* Use `.env` or environment variables in production.